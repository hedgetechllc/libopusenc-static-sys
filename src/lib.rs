#![no_std]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/* automatically generated by rust-bindgen 0.71.1 */

pub const OPE_API_VERSION: u32 = 0;
pub const OPE_OK: u32 = 0;
pub const OPE_BAD_ARG: i32 = -11;
pub const OPE_INTERNAL_ERROR: i32 = -13;
pub const OPE_UNIMPLEMENTED: i32 = -15;
pub const OPE_ALLOC_FAIL: i32 = -17;
pub const OPE_CANNOT_OPEN: i32 = -30;
pub const OPE_TOO_LATE: i32 = -31;
pub const OPE_INVALID_PICTURE: i32 = -32;
pub const OPE_INVALID_ICON: i32 = -33;
pub const OPE_WRITE_FAIL: i32 = -34;
pub const OPE_CLOSE_FAIL: i32 = -35;
pub const OPE_SET_DECISION_DELAY_REQUEST: u32 = 14000;
pub const OPE_GET_DECISION_DELAY_REQUEST: u32 = 14001;
pub const OPE_SET_MUXING_DELAY_REQUEST: u32 = 14002;
pub const OPE_GET_MUXING_DELAY_REQUEST: u32 = 14003;
pub const OPE_SET_COMMENT_PADDING_REQUEST: u32 = 14004;
pub const OPE_GET_COMMENT_PADDING_REQUEST: u32 = 14005;
pub const OPE_SET_SERIALNO_REQUEST: u32 = 14006;
pub const OPE_GET_SERIALNO_REQUEST: u32 = 14007;
pub const OPE_SET_PACKET_CALLBACK_REQUEST: u32 = 14008;
pub const OPE_SET_HEADER_GAIN_REQUEST: u32 = 14010;
pub const OPE_GET_HEADER_GAIN_REQUEST: u32 = 14011;
pub const OPE_GET_NB_STREAMS_REQUEST: u32 = 14013;
pub const OPE_GET_NB_COUPLED_STREAMS_REQUEST: u32 = 14015;
pub type opus_int16 = i16;
pub type opus_int32 = i32;
pub type opus_uint32 = u32;
#[doc = "Called for writing a page.\n\n# Arguments\n\n* `user_data` - user-defined data passed to the callback\n* `ptr` -       buffer to be written\n* `len` -       number of bytes to be written\n\n# Returns\n\nerror code\n\\retval 0        success\n\\retval 1        failure"]
pub type ope_write_func = ::core::option::Option<
  unsafe extern "C" fn(
    user_data: *mut ::core::ffi::c_void,
    ptr: *const ::core::ffi::c_uchar,
    len: opus_int32,
  ) -> ::core::ffi::c_int,
>;
#[doc = "Called for closing a stream.\n\n# Arguments\n\n* `user_data` - user-defined data passed to the callback\n\n# Returns\n\nerror code\n\\retval 0        success\n\\retval 1        failure"]
pub type ope_close_func =
  ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int>;
#[doc = "Called on every packet encoded (including header).\n\n# Arguments\n\n* `user_data` -   user-defined data passed to the callback\n* `packet_ptr` -  packet data\n* `packet_len` -  number of bytes in the packet\n* `flags` -       optional flags (none defined for now so zero)"]
pub type ope_packet_func = ::core::option::Option<
  unsafe extern "C" fn(
    user_data: *mut ::core::ffi::c_void,
    packet_ptr: *const ::core::ffi::c_uchar,
    packet_len: opus_int32,
    flags: opus_uint32,
  ),
>;
#[doc = "Callback functions for accessing the stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusEncCallbacks {
  #[doc = "Callback for writing to the stream."]
  pub write: ope_write_func,
  #[doc = "Callback for closing the stream."]
  pub close: ope_close_func,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OggOpusComments {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OggOpusEnc {
  _unused: [u8; 0],
}
unsafe extern "C" {
  #[doc = "Create a new comments object.\n\n# Returns\n\nNewly-created comments object."]
  pub fn ope_comments_create() -> *mut OggOpusComments;
  #[doc = "Create a deep copy of a comments object.\n\n# Arguments\n\n* `comments` - Comments object to copy\n\n# Returns\n\nDeep copy of input."]
  pub fn ope_comments_copy(comments: *mut OggOpusComments) -> *mut OggOpusComments;
  #[doc = "Destroys a comments object.\n\n# Arguments\n\n* `comments` - Comments object to destroy"]
  pub fn ope_comments_destroy(comments: *mut OggOpusComments);
  #[doc = "Add a comment.\n\n# Arguments\n\n* `comments` [in,out]  - Where to add the comments\n* `tag` -      Tag for the comment (must not contain = char)\n* `val` -      Value for the tag\n\n# Returns\n\nError code"]
  pub fn ope_comments_add(
    comments: *mut OggOpusComments,
    tag: *const ::core::ffi::c_char,
    val: *const ::core::ffi::c_char,
  ) -> ::core::ffi::c_int;
  #[doc = "Add a comment as a single tag=value string.\n\n# Arguments\n\n* `comments` [in,out]  -    Where to add the comments\n* `tag_and_val` - string of the form tag=value (must contain = char)\n\n# Returns\n\nError code"]
  pub fn ope_comments_add_string(
    comments: *mut OggOpusComments,
    tag_and_val: *const ::core::ffi::c_char,
  ) -> ::core::ffi::c_int;
  #[doc = "Add a picture from a file.\n\n# Arguments\n\n* `comments` [in,out]  -     Where to add the comments\n* `filename` -     File name for the picture\n* `picture_type` - Type of picture (-1 for default)\n* `description` -  Description (NULL means no comment)\n\n# Returns\n\nError code"]
  pub fn ope_comments_add_picture(
    comments: *mut OggOpusComments,
    filename: *const ::core::ffi::c_char,
    picture_type: ::core::ffi::c_int,
    description: *const ::core::ffi::c_char,
  ) -> ::core::ffi::c_int;
  #[doc = "Add a picture already in memory.\n\n# Arguments\n\n* `comments` [in,out]  -     Where to add the comments\n* `ptr` -          Pointer to picture in memory\n* `size` -         Size of picture pointed to by ptr\n* `picture_type` - Type of picture (-1 for default)\n* `description` -  Description (NULL means no comment)\n\n# Returns\n\nError code"]
  pub fn ope_comments_add_picture_from_memory(
    comments: *mut OggOpusComments,
    ptr: *const ::core::ffi::c_char,
    size: usize,
    picture_type: ::core::ffi::c_int,
    description: *const ::core::ffi::c_char,
  ) -> ::core::ffi::c_int;
  #[doc = "Create a new OggOpus file.\n\n# Arguments\n\n* `path` -       Path where to create the file\n* `comments` -   Comments associated with the stream\n* `rate` -       Input sampling rate (48 kHz is faster)\n* `channels` -   Number of channels\n* `family` -     Mapping family (0 for mono/stereo, 1 for surround)\n* `error` [out]  - Error code (NULL if no error is to be returned)\n\n# Returns\n\nNewly-created encoder."]
  pub fn ope_encoder_create_file(
    path: *const ::core::ffi::c_char,
    comments: *mut OggOpusComments,
    rate: opus_int32,
    channels: ::core::ffi::c_int,
    family: ::core::ffi::c_int,
    error: *mut ::core::ffi::c_int,
  ) -> *mut OggOpusEnc;
  #[doc = "Create a new OggOpus stream to be handled using callbacks\n\n# Arguments\n\n* `callbacks` -  Callback functions\n* `user_data` -  Pointer to be associated with the stream and passed to the callbacks\n* `comments` -   Comments associated with the stream\n* `rate` -       Input sampling rate (48 kHz is faster)\n* `channels` -   Number of channels\n* `family` -     Mapping family (0 for mono/stereo, 1 for surround)\n* `error` [out]  - Error code (NULL if no error is to be returned)\n\n# Returns\n\nNewly-created encoder."]
  pub fn ope_encoder_create_callbacks(
    callbacks: *const OpusEncCallbacks,
    user_data: *mut ::core::ffi::c_void,
    comments: *mut OggOpusComments,
    rate: opus_int32,
    channels: ::core::ffi::c_int,
    family: ::core::ffi::c_int,
    error: *mut ::core::ffi::c_int,
  ) -> *mut OggOpusEnc;
  #[doc = "Create a new OggOpus stream to be used along with.ope_encoder_get_page().\nThis is mostly useful for muxing with other streams.\n\n# Arguments\n\n* `comments` -   Comments associated with the stream\n* `rate` -       Input sampling rate (48 kHz is faster)\n* `channels` -   Number of channels\n* `family` -     Mapping family (0 for mono/stereo, 1 for surround)\n* `error` [out]  - Error code (NULL if no error is to be returned)\n\n# Returns\n\nNewly-created encoder."]
  pub fn ope_encoder_create_pull(
    comments: *mut OggOpusComments,
    rate: opus_int32,
    channels: ::core::ffi::c_int,
    family: ::core::ffi::c_int,
    error: *mut ::core::ffi::c_int,
  ) -> *mut OggOpusEnc;
  #[doc = "Deferred initialization of the encoder to force an explicit channel mapping. This can be used to override the default channel coupling,\nbut using it for regular surround will almost certainly lead to worse quality.\n\n# Arguments\n\n* `enc` [in,out]  -         Encoder\n* `family` -              Mapping family (0 for mono/stereo, 1 for surround)\n* `streams` -             Total number of streams\n* `coupled_streams` -     Number of coupled streams\n* `mapping` -             Channel mapping\n\n# Returns\n\nError code"]
  pub fn ope_encoder_deferred_init_with_mapping(
    enc: *mut OggOpusEnc,
    family: ::core::ffi::c_int,
    streams: ::core::ffi::c_int,
    coupled_streams: ::core::ffi::c_int,
    mapping: *const ::core::ffi::c_uchar,
  ) -> ::core::ffi::c_int;
  #[doc = "Add/encode any number of float samples to the stream.\n\n# Arguments\n\n* `enc` [in,out]  -         Encoder\n* `pcm` -                 Floating-point PCM values in the +/-1 range (interleaved if multiple channels)\n* `samples_per_channel` - Number of samples for each channel\n\n# Returns\n\nError code"]
  pub fn ope_encoder_write_float(
    enc: *mut OggOpusEnc,
    pcm: *const f32,
    samples_per_channel: ::core::ffi::c_int,
  ) -> ::core::ffi::c_int;
  #[doc = "Add/encode any number of 16-bit linear samples to the stream.\n\n# Arguments\n\n* `enc` [in,out]  -         Encoder\n* `pcm` -                 Linear 16-bit PCM values in the [-32768,32767] range (interleaved if multiple channels)\n* `samples_per_channel` - Number of samples for each channel\n\n# Returns\n\nError code"]
  pub fn ope_encoder_write(
    enc: *mut OggOpusEnc,
    pcm: *const opus_int16,
    samples_per_channel: ::core::ffi::c_int,
  ) -> ::core::ffi::c_int;
  #[doc = "Get the next page from the stream (only if using ope_encoder_create_pull()).\n\n# Arguments\n\n* `enc` [in,out]  - Encoder\n* `page` [out]  -   Next available encoded page\n* `len` [out]  -    Size (in bytes) of the page returned\n* `flush` -       If non-zero, forces a flush of the page (if any data avaiable)\n\n# Returns\n\n1 if there is a page available, 0 if not."]
  pub fn ope_encoder_get_page(
    enc: *mut OggOpusEnc,
    page: *mut *mut ::core::ffi::c_uchar,
    len: *mut opus_int32,
    flush: ::core::ffi::c_int,
  ) -> ::core::ffi::c_int;
  #[doc = "Finalizes the stream, but does not deallocate the object.\n\n# Arguments\n\n* `enc` [in,out]  - Encoder\n\n# Returns\n\nError code"]
  pub fn ope_encoder_drain(enc: *mut OggOpusEnc) -> ::core::ffi::c_int;
  #[doc = "Deallocates the obect. Make sure to ope_drain() first.\n\n# Arguments\n\n* `enc` [in,out]  - Encoder"]
  pub fn ope_encoder_destroy(enc: *mut OggOpusEnc);
  #[doc = "Ends the stream and create a new stream within the same file.\n\n# Arguments\n\n* `enc` [in,out]  - Encoder\n* `comments` -   Comments associated with the stream\n\n# Returns\n\nError code"]
  pub fn ope_encoder_chain_current(enc: *mut OggOpusEnc, comments: *mut OggOpusComments) -> ::core::ffi::c_int;
  #[doc = "Ends the stream and create a new file.\n\n# Arguments\n\n* `enc` [in,out]  - Encoder\n* `path` -        Path where to write the new file\n* `comments` -    Comments associated with the stream\n\n# Returns\n\nError code"]
  pub fn ope_encoder_continue_new_file(
    enc: *mut OggOpusEnc,
    path: *const ::core::ffi::c_char,
    comments: *mut OggOpusComments,
  ) -> ::core::ffi::c_int;
  #[doc = "Ends the stream and create a new file (callback-based).\n\n# Arguments\n\n* `enc` [in,out]  - Encoder\n* `user_data` -   Pointer to be associated with the new stream and passed to the callbacks\n* `comments` -    Comments associated with the stream\n\n# Returns\n\nError code"]
  pub fn ope_encoder_continue_new_callbacks(
    enc: *mut OggOpusEnc,
    user_data: *mut ::core::ffi::c_void,
    comments: *mut OggOpusComments,
  ) -> ::core::ffi::c_int;
  #[doc = "Write out the header now rather than wait for audio to begin.\n\n# Arguments\n\n* `enc` [in,out]  - Encoder\n\n# Returns\n\nError code"]
  pub fn ope_encoder_flush_header(enc: *mut OggOpusEnc) -> ::core::ffi::c_int;
  #[doc = "Sets encoder options.\n\n# Arguments\n\n* `enc` [in,out]  - Encoder\n* `request` -     Use a request macro\n\n# Returns\n\nError code"]
  pub fn ope_encoder_ctl(enc: *mut OggOpusEnc, request: ::core::ffi::c_int, ...) -> ::core::ffi::c_int;
  #[doc = "Converts a libopusenc error code into a human readable string.\n\n# Arguments\n\n* `error` - Error number\n\n# Returns\n\nError string"]
  pub fn ope_strerror(error: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
  #[doc = "Returns a string representing the version of libopusenc being used at run time.\n\n# Returns\n\nA string describing the version of this library"]
  pub fn ope_get_version_string() -> *const ::core::ffi::c_char;
  #[doc = "ABI version for this header. Can be used to check for features at run time.\n\n# Returns\n\nAn integer representing the ABI version"]
  pub fn ope_get_abi_version() -> ::core::ffi::c_int;
}
